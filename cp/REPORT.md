# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Никулин Кристиан Ильич

## Результат проверки

Вариант задания:

 - [X] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В ходе выполнения проекта я научусь обрабатывать генеалогические деревья в формате GEDCOM, писать парсер на каком-нибудь языке программирования для обработки GEDCOM файла в набор предикатов языка Prolog. На самом Прологе я научусь создавать запросы для проверки связей между людьми (кто кому приходится).

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM.
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: child(ребенок, родитель), male(человек), female(человек).
3. Реализовать предикат проверки/поиска деверя (брат мужа по отношению к жене).
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве. 

## Получение родословного дерева

Я получил дерево при помощи программы Gramps, количество индивидов в дереве - 22.

## Конвертация родословного дерева

Я использовал язык программирования Python.

Для решения поставленной задачи я создал два словаря: для личности и для пола. Так как у каждого человека есть свой ID, будем определять человека благодаря считыванию индификатора INDI, а далее записывать его данные в словарь личности. В конце описания каждой личности выписываем ребенка и каждого его родителя по отдельности с использованием предиката child(ребенок, родитель), если они есть:

```python
for line in gedcom:
    if "INDI" in line:
    # ...
    elif "CHIL" in line: # CHIL - означает, что со следующей строки начнется описание следующей личности
        child = line[9:13]
        prolog.write("child('"+name[child]+"', '"+name[father]+"').\n")
        prolog.write("child('"+name[child]+"', '"+name[mother]+"').\n")
```

Отдельным циклом проходимся по словарю sex и выписываем пол каждой личности:
```python
for key in name:
    if sex[key] == 'F':
        prolog.write("female('"+name[key]+"').\n")
    else:
        prolog.write("male('"+name[key]+"').\n")
```

## Предикат поиска родственника

В моём задании нужно найти деверя (брат мужа для жены). Нужно проверить, что у женщины есть муж и у мужа есть брат. Для этого мы будем использовать следующие предикаты:
```prolog
husband(Man, Woman) :-
    male(Man),
    female(Woman),
    child(Child, Man),
    child(Child, Woman).

brother(Person, Brother) :-
    male(Person),
    male(Brother),
    child(Person, Parent),
    child(Brother, Parent),
    not(Person = Brother).

dever(Woman, Y) :-
    husband(Husband, Woman),
    brother(Husband, Y).
```

## Определение степени родства

Напишем предикаты для всех родственников, используя первоначальные предикаты - ```child(X,Y)```, ```male(X)```, ```female(X)```:
```prolog
father(X, Y) :- child(Y, X), male(X), X \= Y.
mother(X, Y) :- child(Y, X), female(X), X \= Y.

son(X, Y) :- child(X, Y), male(X), X \= Y.
daughter(X, Y) :- child(X, Y), female(X), X \= Y.

husband(X, Y) :- child(Z, X), child(Z, Y), male(X), X \= Y.
wife(X, Y) :- child(Z, X), child(Z, Y), female(X), X \= Y.

brother(X, Y) :- child(X, Z), child(Y, Z), male(X), X \= Y.
sister(X, Y) :- child(X, Z), child(Y, Z), female(X),  X \= Y.
```
```prolog
% отношения
kinship('father', Father, Child) :- father(Father, Child).
kinship('mother', Mother, Child) :-  mother(Mother, Child).

kinship('son', Child, Parent) :- son(Child, Parent).
kinship('daughter', Child, Parent) :- daughter(Child, Parent).

kinship('husband', Husband, Wife) :- husband(Husband, Wife).
kinship('wife', Wife, Husband) :- wife(Wife, Husband).

kinship('brother', Brother, Y) :- brother(Brother, Y).
kinship('sister', Sister, Y) :- sister(Sister, Y).
```

Напишем общий предикат ```relative(R, X, Y)```, который принимает ```R``` - список родственных отношений и ```X```, ```Y``` - два человека из дерева. В ```R``` для заданного человека ```X``` будут выводится не только списки отношения с родственником ```Y```, но и список с ближайшими родственниками человека ```Y``` (см. пример).

```prolog
perm(X, Y) :- kinship(_, X, Y).
prolong([X | T], [Y, X | T]) :- perm(X, Y), not(member(Y, [X | T])).

bfs([[H | T] | _], H, [H | T]).
bfs([H|T], Res, Tree) :- findall(W, prolong(H, W), Trees), append(T, Trees, Newtrees), !, bfs(Newtrees, Res, Tree).

find([_], R, R).
find([X, Y | T], R, Relation) :- kinship(Re, X, Y), find([Y | T], [Re | R], Relation).

relative(Relation, X, Y) :- bfs([[X]], Y, R), reverse(R, Re), find(Re, [], Newrel), reverse(Newrel, Relation), N is 0.
```

## Естественно-языковый интерфейс

## Выводы

Благодаря данной лабораторной работе познакомился с основными принципами обработки естественных языков. Реализовал предикат, который разбирает слово по составу. 

Пролог яляется логическим языков программирования. Создание предикатов является логически понятным и простым в освоении для человека, так как это очень похоже но то, как мы рассуждаем. В языке есть правила и факты, где факт это то, что мы уже знаем, а правило - закономерность, базирующаяся на фактах. Запрос пролога представляет собой обход дерева и бэктрекинг для поиска новых решений. В прологе есть механизм отсечения, а также есть возможность написать много стандартных алгоритмов. 

Изучая язык программирования Пролог, я научился работать со списками, писать различные предикаты отношений, объединять предикаты в один общий предикат, использовать рекурсию и механизм отсечения.
