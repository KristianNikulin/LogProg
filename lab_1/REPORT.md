# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Никулин К. И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список в языке Пролог - это последовательность из элементов. При работе со списками не указывается конкретный тип данных внутри списка, но все элементы списка должны иметь единый тип, не требуется указание размерности списка. Обрабатывать элементы списка в Прологе можно только рекурсивно, разделяя список на голову и хвост.

Списки в Прологе похожи на такие структуры данных в традиционных языках как стек и массив, однако все равно есть различия, например, доступ к произвольному элементу, который в массиве выполняется за линейное время, а в списке пролога за время n т.к. требуется n операций перехода по ссылкам до n-ого элемента.

## Задание 1.1: Предикат обработки списка

`list_delete_1(L, X, R)` - отделяет хвост, начиная с элемента с данным значением С ИСПОЛЬЗОВАНИЕМ стандартных предикатов
`list_delete_2(L, X, R)` - отделяет хвост, начиная с элемента с данным значением БЕЗ ИСПОЛЬЗОВАНИЯ стандартных предикатов

Примеры использования:
```prolog
?- list_delete_1([1, 2, 3, 4, 5, 6, 7, 8, 9], 5, X).
X = [1, 2, 3, 4].
?- list_delete_1([6, 7, 8, 9], 6, X).
X = [].
```

Реализация:
```prolog
list_delete_1(L, X, R) :- append(R, [X|_], L), !.
list_delete_1(L, X, R) :- append(R, [], L).
```
```prolog
list_delete_2([], X, []) :- !.
list_delete_2([X|T], X, []) :- !.
list_delete_2([H|T], X, [H|R]) :- list_delete_2(T, X, R).
```
list_delete_1(L, X, R) - на вход поступает список и значение, начиная с которого надо отделить хвост списка. Через стандартный предикат append осуществляем конкатенацию списков, после чего отделяем список начиная с данного элемента.

list_delete_2(L, X, R) - рекурсивная реализация. При удалении элемента Х из пустого списка будет пустой список; при удалении элемента Х из списка вида [X|T] будет пустой список.

## Задание 1.2: Предикат обработки числового списка

`list_multiplication(L, X).` -  вычисляет произведение элементов списка

Примеры использования:
```prolog
?- list_multiplication([1, 2, 3, 4, 5], X).
X = 120.
?- list_multiplication([5, 5, 5, 5], X).
X = 625.
```

Реализация:
```prolog
list_multiplication([], 1).
list_multiplication([Head|Tail], X) :- list_multiplication(Tail, X1), X is Head * X1.
```
list_multiplication(L, X) - рекурсивная реализация. Пишем условие, что произведение в пустом списке равно единице. С конца списка начинаем перемножать элементы, умножая результат в хвосте на голову списка.

## Задание 1.3: Пример совместного использования предикатов

`list_delete_length(L, X, Answer).` -  отделение хвоста, начиная с элемента с данным значением, подсчет и вывод длины получившегося списка

Примеры использования:
```prolog
?- list_delete_length([1, 2, 3, 4, 5, 6, 7, 8, 9], 5, L).
L = 4
?- list_delete_length([6, 7, 8, 9], 6, L).
L = 0
```

Реализация:
```prolog
list_delete_length(L, X, Answer) :- list_delete_1(L, X, L2), length(L2, Answer).
```
list_delete_length(L, X, Answer) - после отделения хвоста начииная с элемента X с помощью list_delete_1(L, X, R), находим длину получившегося списка с помощью предиката length

## Задание 2: Реляционное представление данных

Самыми главными приемуществами реляционной модели являются простота, доступность для понимания пользователем и полная независимость данных. Но у реляционной модели есть и недостатки, нарпимер, низкая скорость доступа к данным, требуется больше объема внешней памяти, не всегда предметную область можно представить в виде совокупности таблиц.

### Представление 1. Вариант 2

1) `amount_of_grades_of_subject(Answer, Name, Subject).` -  средний балл для данного предмета

Примеры использования:
```prolog
?- average_grade_in_subject('LP', X).
X = 3.9642857142857144.
?- average_grade_in_subject(S, X).
S = 'ENG',
X = 4.178571428571429 ;
S = 'FP',
X = 3.892857142857143 ;
S = 'INF',
X = 3.5714285714285716 ;
S = 'LP',
X = 3.9642857142857144 ;
S = 'MTH',
X = 3.6785714285714284 ;
S = 'PSY',
X = 3.607142857142857.
```

Реализация:
```prolog
amount_of_grades_of_subject(Answer, Name, Subject) :- grade(Name, Subject, Answer).

average_grade_in_subject(Subject, Answer) :- 
bagof(X, amount_of_grades_of_subject(2, X, Subject), Grade_2), 
bagof(X, amount_of_grades_of_subject(3, X, Subject), Grade_3), 
bagof(X, amount_of_grades_of_subject(4, X, Subject), Grade_4), 
bagof(X, amount_of_grades_of_subject(5, X, Subject), Grade_5),

length(Grade_2, Count_grade_2), 
length(Grade_3, Count_grade_3), 
length(Grade_4, Count_grade_4), 
length(Grade_5, Count_grade_5), 

Count_of_all_grades_of_subfect is Count_grade_2 + Count_grade_3 + Count_grade_4 + Count_grade_5, 
Summ_of_all_grades_of_subfect is Count_grade_2 * 2 + Count_grade_3 * 3 + Count_grade_4 * 4 + Count_grade_5 * 5, 
Answer is Summ_of_all_grades_of_subfect / Count_of_all_grades_of_subfect.
```
Получаем 5 списков всех видов оценок по предмету, подсчитываем сумму всех баллов по этому предмету (сумму длин списков), считаем средний балл (сумму оценок делим на количество оценок).

2) `names_of_failed_students(Name, Group)` - количество не сдавших студентов для каждой группы

Примеры использования:
```prolog
?- count_of_failed_students(101, X).
X = 2.
?- count_of_failed_students(103, X).
X = 3.
?- count_of_failed_students(G, X).
G = 101,
X = 2 ;
G = 102,
X = 4 ;
G = 103,
X = 3 ;
G = 104,
X = 4.
```

Реализация:
```prolog
names_of_failed_students(Name, Group) :- grade(Name, _, 2), student(Group, Name).
count_of_failed_students(Group, Answer) :- setof(X, names_of_failed_students(X, Group), List), length(List, Answer).
```
С помощью setof получаем упорядоченный список List студентов (без повторений) нужной группы кто не сдал экзамен (оценка 2) и с помощью предиката length считаем количество несдавших студентов (длину List)

3) `count_of_failed_students_subject(Subject, Answer)` - количество не сдавших студентов для каждого из предметов

Примеры использования:
```prolog
?- count_of_failed_students_subject('LP', X).
X = 3.
?- count_of_failed_students_subject(S, X).
S = 'ENG',
X = 1 ;
S = 'FP',
X = 1 ;
S = 'INF',
X = 3 ;
S = 'LP',
X = 3 ;
S = 'MTH',
X = 6 ;
S = 'PSY',
X = 5.
```

Реализация:
```prolog
count_of_failed_students_subject(Subject, Answer) :- bagof(X, grade(X, Subject, 2), List), length(List, Answer).
```
С помощью bagof получаем список List студентов кто не сдал экзамен (оценка 2) по заданному предмету и с помощью length считаем количество несдавших студентов (длину List)

## Выводы

Данная лабораторная работа стала моим первым шагом в освоении логического языка программирования Пролог. Во время её выполнения я научился работать со списками, стандартными предикатами и реляционным представлением данных. Я стал лучше понимать как устроено декларативное программирование и в каких случаях оно имеет приемущество по сравнению с императивным программированием. Подводя итог, хотелось бы сказать, что в соврменном мире Пролог мало где применяется, в силу своей специфичности, но я считаю, что его знание необходимо каждому программисту для развития нестандартного мышления и нахождению нетривиального решения для какой-либо задачи.
